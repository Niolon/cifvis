import { CellSymmetry } from '../../cell-symmetry.js';
import { Atom, CrystalStructure } from '../../crystal.js';

import { create, all } from 'mathjs';
import { createSymAtomLabel } from './grow-fragment.js';

const math = create(all, {});

/**
 * @typedef {object} FractionalLimits
 * @property {number} minX - Minimum fractional X coordinate.
 * @property {number} maxX - Maximum fractional X coordinate.
 * @property {number} minY - Minimum fractional Y coordinate.
 * @property {number} maxY - Maximum fractional Y coordinate.
 * @property {number} minZ - Minimum fractional Z coordinate.
 * @property {number} maxZ - Maximum fractional Z coordinate.
 */

/**
 * Creates a set of symmetry element that will fill the complete cell, when executed subsequently on the
 * fragment grown from previously grown sets
 * @param {CellSymmetry} symmetry - Cell symmetry for which the minimal set should be determined
 * @param {string[]} preexistingSymOps - Symmetry elements already generated by growing of Fragmnt
 * @returns {string[]} - Array containing the ids of the unique set.
 */
export function minimalGrowthSet(symmetry, preexistingSymOps) {
    const generatedSet = new Set();
    const keepSet = new Set([symmetry.identitySymOpId]);

    preexistingSymOps.forEach(exist_id => {
        const combinedId = symmetry.combineSymmetryCodes(exist_id + '_555', symmetry.identitySymOpId + '_555');

        generatedSet.add(combinedId.split('_')[0]);
    });

    // console.log(generatedSet); // Debugging: remove
    symmetry.operationIds.keys().forEach( id => {
        if (keepSet.has(id) || generatedSet.has(id)) {
            return;
        }
        preexistingSymOps.forEach(exist_id => {
            const combinedId = symmetry.combineSymmetryCodes(exist_id + '_555', id + '_555');

            generatedSet.add(combinedId.split('_')[0]);
        });

        keepSet.forEach(exist_id => {
            const combinedId = symmetry.combineSymmetryCodes(exist_id + '_555', id + '_555');
            generatedSet.add(combinedId.split('_')[0]);
        });
        keepSet.add(id); 
    });
    return keepSet;
}

/**
 * Calculates the minimum and maximum fractional coordinates (x, y, z)
 * for all atoms in the asymmetric unit of the provided crystal structure.
 * @param {Atom[]} atoms - The atoms to analyze.
 * @returns {FractionalLimits} An object containing the min/max fractional coordinates.
 */
export function getFragmentLimits(atoms) {
    let minX, maxX;
    let minY, maxY;
    let minZ, maxZ;

    for (const atom of atoms) {
        if (minX === undefined || atom.position.x < minX) {
            minX = atom.position.x;
        }
        if (maxX === undefined || atom.position.x > maxX) {
            maxX = atom.position.x;
        }
        if (minY === undefined || atom.position.y < minY) {
            minY = atom.position.y;
        }
        if (maxY === undefined || atom.position.y > maxY) {
            maxY = atom.position.y;
        }
        if (minZ === undefined || atom.position.z < minZ) {
            minZ = atom.position.z;
        }
        if (maxZ === undefined || atom.position.z > maxZ) {
            maxZ = atom.position.z;
        }
    }
    return { minX, maxX, minY, maxY, minZ, maxZ };
}

/**
 * Applies a symmetry operation to fractional coordinate limits.
 * @param {FractionalLimits} limits - The initial fractional coordinate limits.
 * @param {SymmetryOperation} symOp - The symmetry operation to apply.
 * @returns {FractionalLimits} The transformed fractional coordinate limits.
 */
export function getSymmetryLimits(limits, symOp) {
    const minVec = math.matrix([limits.minX, limits.minY, limits.minZ]);
    const maxVec = math.matrix([limits.maxX, limits.maxY, limits.maxZ]);
    const symmMinVec = math.add(math.multiply(symOp.rotMatrix, minVec), math.matrix(symOp.transVector));
    const symmMaxVec = math.add(math.multiply(symOp.rotMatrix, maxVec), math.matrix(symOp.transVector));
    return {
        minX: symmMinVec.get([0]) < symmMaxVec.get([0]) ? symmMinVec.get([0]) : symmMaxVec.get([0]),
        maxX: symmMinVec.get([0]) > symmMaxVec.get([0]) ? symmMinVec.get([0]) : symmMaxVec.get([0]),
        minY: symmMinVec.get([1]) < symmMaxVec.get([1]) ? symmMinVec.get([1]) : symmMaxVec.get([1]),
        maxY: symmMinVec.get([1]) > symmMaxVec.get([1]) ? symmMinVec.get([1]) : symmMaxVec.get([1]),
        minZ: symmMinVec.get([2]) < symmMaxVec.get([2]) ? symmMinVec.get([2]) : symmMaxVec.get([2]),
        maxZ: symmMinVec.get([2]) > symmMaxVec.get([2]) ? symmMinVec.get([2]) : symmMaxVec.get([2]),
    };  
}

/**
 *
 * @param limits
 * @param symmetry
 */
export function getSymmetryCentre(limits, symmetry) {
    const symmLimits = getSymmetryLimits(limits, symmetry);
    return {
        x: (symmLimits.minX + symmLimits.maxX) / 2,
        y: (symmLimits.minY + symmLimits.maxY) / 2,
        z: (symmLimits.minZ + symmLimits.maxZ) / 2,
    };
}

/**
 * 
 * @param atomGroups
 * @param {CrystalStructure} structure 
 */
function evaluateAtomGroupsGrown(atomGroups, structure) {
    const identitySymOp = structure.symmetry.identitySymOpId;
    const presentSymmetries = atomGroups.map(g => {
        const groupSymmetries = new Set();
        for (const atom of g.atoms) {
            const labelSplit = atom.label.split('@');
            if (labelSplit.length === 2) {
                groupSymmetries.add(labelSplit[1].split('_')[0]);
            } else if (labelSplit.length === 1) {
                groupSymmetries.add(`${identitySymOp}`);
            }
        }
        const symArray = Array.from(groupSymmetries);
        //symArray.sort();
        return symArray;
    });

    return presentSymmetries;
}

/**
 *
 * @param {CrystalStructure} structure
 * @param cutFragments
 */
export function growCell(structure, cutFragments = true) {
    const atomGroups = structure.calculateConnectedGroups();
    const presentSymmetries = evaluateAtomGroupsGrown(atomGroups, structure);
    //console.log(presentSymmetries)

    const limits = getFragmentLimits(structure.atoms);

    const growSymIds = presentSymmetries.map(groupSymm => {
        return minimalGrowthSet(structure.symmetry, groupSymm);
    });
    //console.log(growSymIds) ;

    const symmIds = structure.symmetry.operationIds;
    const identityId = structure.symmetry.identitySymOpId;
    
    const newAtoms = [];
    const newBonds = [];
    const newHBonds = [];

    const growAtoms = [...structure.atoms];
    const growBonds = [...structure.bonds];
    const growHBonds = [...structure.hBonds];
    for (const groupIds of growSymIds) {
        for (const id of groupIds) {
            const symOp = structure.symmetry.symmetryOperations[symmIds.get(id)];

            const symmCentre = getSymmetryCentre(limits, symOp);

            // Calculate the offsets as integers
            const offsetX = Math.floor(symmCentre.x);
            const offsetY = Math.floor(symmCentre.y);
            const offsetZ = Math.floor(symmCentre.z);
            const translationString = `${5 + offsetX}${5 + offsetY}${5 + offsetZ}`;
            //console.log(id, translationString)

            // const newLimits = getSymmetryLimits(limits, symOp]
            // apply symmetry to growFragment
            const symmString = `${id}_${translationString}`;
            const symmAtoms = structure.symmetry.applySymmetry(symmString, growAtoms);

            symmAtoms.forEach(atom => {
                const labelSplit = atom.label.split('@');
                if (labelSplit.length === 2) {
                    const symmId = structure.symmetry.combineSymmetryCodes(symmString, labelSplit[1]);
                    atom.label = createSymAtomLabel(labelSplit[0], symmId);
                } else if (labelSplit.length === 1) {
                    atom.label = createSymAtomLabel(atom.label, symmString);
                } else {
                    throw new Error(`Encountered invalid atom label ${atom.label} (did not expect multiple symmetry indicating @)`);
                }
            });
        }
        // check and filter atoms on special positions

        // add bonds with filtered atom labels

        // add hbonds with filtered atom labels

        // if combineGrows replace growFragment with combined new and grown atoms and bonds
    }

}