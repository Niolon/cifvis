import { CellSymmetry } from '../../cell-symmetry.js';
import { Atom, CrystalStructure } from '../../crystal.js';
import { Bond, HBond } from '../../bonds.js';
import { create, all } from 'mathjs';
import { createSymAtomLabel, createBondIdentifier, createHBondIdentifier } from './grow-fragment.js';

const math = create(all, {});

/**
 * @typedef {object} FractionalLimits
 * @property {number} minX - Minimum fractional X coordinate.
 * @property {number} maxX - Maximum fractional X coordinate.
 * @property {number} minY - Minimum fractional Y coordinate.
 * @property {number} maxY - Maximum fractional Y coordinate.
 * @property {number} minZ - Minimum fractional Z coordinate.
 * @property {number} maxZ - Maximum fractional Z coordinate.
 */

/**
 * Creates a set of symmetry elements that will fill the complete cell when executed subsequently
 * on the fragment grown from previously grown sets.
 * @param {CellSymmetry} symmetry - Cell symmetry for which the minimal set should be determined
 * @param {string[]} preexistingSymOps - Symmetry elements already generated by growing of fragment
 * @returns {Set<string>} - Set containing the ids of the unique set
 */
export function minimalGrowthSet(symmetry, preexistingSymOps) {
    const generatedSet = new Set();
    const keepSet = new Set([symmetry.identitySymOpId]);

    // Add all symmetry operations that can be generated from preexisting ones
    for (const existId of preexistingSymOps) {
        const combinedId = symmetry.combineSymmetryCodes(existId + '_555', symmetry.identitySymOpId + '_555');
        generatedSet.add(combinedId.split('_')[0]);
    }

    // Find minimal set needed to generate all symmetry operations
    for (const [id] of symmetry.operationIds) {
        if (keepSet.has(id) || generatedSet.has(id)) {
            continue;
        }

        // Check if this operation can be generated from existing operations
        let canBeGenerated = false;
        for (const existId of [...preexistingSymOps, ...keepSet]) {
            const combinedId = symmetry.combineSymmetryCodes(existId + '_555', id + '_555');
            if (generatedSet.has(combinedId.split('_')[0])) {
                canBeGenerated = true;
                break;
            }
        }

        if (!canBeGenerated) {
            keepSet.add(id);
            // Update generated set with new combinations
            for (const existId of preexistingSymOps) {
                const combinedId = symmetry.combineSymmetryCodes(existId + '_555', id + '_555');
                generatedSet.add(combinedId.split('_')[0]);
            }
        }
    }

    return keepSet;
}

/**
 * Calculates the minimum and maximum fractional coordinates for all atoms.
 * @param {Atom[]} atoms - The atoms to analyze
 * @returns {FractionalLimits} An object containing the min/max fractional coordinates
 */
export function getFragmentLimits(atoms) {
    if (atoms.length === 0) {
        return { minX: 0, maxX: 1, minY: 0, maxY: 1, minZ: 0, maxZ: 1 };
    }

    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;

    for (const atom of atoms) {
        const { x, y, z } = atom.position;
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
        minZ = Math.min(minZ, z);
        maxZ = Math.max(maxZ, z);
    }

    return { minX, maxX, minY, maxY, minZ, maxZ };
}


/**
 * Calculates the center of symmetry-transformed limits.
 * @param {FractionalLimits} limits - Original limits
 * @param {object} symmetry - Symmetry operation
 * @returns {{x: number, y: number, z: number}} Center coordinates
 */
export function getSymmetryCentre(limits, symOp) {

    const centre = math.matrix([
        (limits.minX + limits.maxX) / 2,
        (limits.minY + limits.maxY) / 2,
        (limits.minZ + limits.maxZ) / 2,
    ]);
    const symmCentre = math.add(
        math.multiply(symOp.rotMatrix, centre),
        symOp.transVector,
    );

    return {
        x: symmCentre.get([0]),
        y: symmCentre.get([1]),
        z: symmCentre.get([2]),
    };
}


/**
 * Extracts unique symmetry operations from atom labels in each group.
 * @param {Array<{atoms: Atom[]}>} atomGroups - Groups of connected atoms
 * @param {CrystalStructure} structure - Crystal structure
 * @returns {Array<string[]>} Array of symmetry operation IDs for each group
 */
function evaluateAtomGroupsGrown(atomGroups, structure) {
    const identitySymOp = structure.symmetry.identitySymOpId;
    
    return atomGroups.map(group => {
        const groupSymmetries = new Set();
        
        for (const atom of group.atoms) {
            const labelParts = atom.label.split('@');
            if (labelParts.length === 2) {
                groupSymmetries.add(labelParts[1].split('_')[0]);
            } else {
                groupSymmetries.add(identitySymOp);
            }
        }
        
        return Array.from(groupSymmetries);
    });
}

/**
 * Checks if an atom position is within the unit cell (0 â‰¤ x,y,z < 1).
 * @param {Atom} atom - Atom to check
 * @param {number} [tolerance] - Tolerance for boundary comparisons
 * @returns {boolean} True if atom is within unit cell
 */
function isWithinUnitCell(atom, tolerance = 1e-6) {
    const { x, y, z } = atom.position;
    return x >= -tolerance && x < 1 - tolerance &&
           y >= -tolerance && y < 1 - tolerance &&
           z >= -tolerance && z < 1 - tolerance;
}

/**
 * Creates a unique key for atom position to detect duplicates/special positions.
 * @param {Atom} atom - Atom to create key for
 * @param {number} [precision] - Decimal places for rounding
 * @returns {string} Position key
 */
function getAtomPositionKey(atom, precision = 4) {
    const factor = Math.pow(10, precision);
    const x = Math.round(atom.position.x * factor) / factor;
    const y = Math.round(atom.position.y * factor) / factor;
    const z = Math.round(atom.position.z * factor) / factor;
    return `${atom.atomType}_${x}_${y}_${z}`;
}

/**
 * Grows a crystal structure to fill a complete unit cell.
 * @param {CrystalStructure} structure - Input crystal structure
 * @param {boolean} [cutFragments] - Whether to exclude atoms outside unit cell
 * @returns {CrystalStructure} New structure filling the unit cell
 */
export function growCell(structure, cutFragments = true) {
    // Early return for empty structures
    if (structure.atoms.length === 0) {
        return new CrystalStructure(
            structure.cell,
            [],
            [],
            [],
            structure.symmetry,
        );
    }

    // Analyze connected groups and their symmetry operations
    const atomGroups = structure.calculateConnectedGroups();
    const presentSymmetries = evaluateAtomGroupsGrown(atomGroups, structure);
    const limits = getFragmentLimits(structure.atoms);
    
    // Determine minimal set of symmetry operations needed for each group
    const growSymIds = presentSymmetries.map(groupSymm => 
        Array.from(minimalGrowthSet(structure.symmetry, groupSymm)),
    );

    // Prepare collections for the grown structure
    const atomMap = new Map(); // position key -> atom
    const bondMap = new Map(); // bond identifier -> bond
    const hbondMap = new Map(); // hbond identifier -> hbond
    const specialPositionMap = new Map(); // duplicate label -> kept label

    // Process each atom group with its required symmetry operations
    for (let groupIdx = 0; groupIdx < atomGroups.length; groupIdx++) {
        const group = atomGroups[groupIdx];
        const symOpsToApply = growSymIds[groupIdx];
        
        for (const symId of symOpsToApply) {
            const symOpIndex = structure.symmetry.operationIds.get(symId);
            const symOp = structure.symmetry.symmetryOperations[symOpIndex];
            
            // Calculate translation to center the transformed group
            const symmCentre = getSymmetryCentre(limits, symOp);
            const offsetX = Math.round(symmCentre.x);
            const offsetY = Math.round(symmCentre.y);
            const offsetZ = Math.round(symmCentre.z);
            const translationString = `${5 + offsetX}${5 + offsetY}${5 + offsetZ}`;
            const symmString = `${symId}_${translationString}`;
            
            // Apply symmetry to atoms
            const transformedAtoms = structure.symmetry.applySymmetry(symmString, group.atoms);
            
            // Process transformed atoms
            for (let i = 0; i < transformedAtoms.length; i++) {
                const atom = transformedAtoms[i];
                const originalLabel = atom.label;
                
                // Update atom label with symmetry information
                const labelParts = originalLabel.split('@');
                if (labelParts.length === 2) {
                    const combinedSymm = structure.symmetry.combineSymmetryCodes(symmString, labelParts[1]);
                    atom.label = createSymAtomLabel(labelParts[0], combinedSymm);
                } else {
                    atom.label = createSymAtomLabel(originalLabel, symmString);
                }
                
                // Check if atom is within unit cell
                if (cutFragments && !isWithinUnitCell(atom)) {
                    continue;
                }
                
                // Check for special positions (duplicates)
                const posKey = getAtomPositionKey(atom);
                const existingAtom = atomMap.get(posKey);
                
                if (existingAtom) {
                    // This is a special position - map to existing atom
                    specialPositionMap.set(atom.label, existingAtom.label);
                } else {
                    // New unique position
                    atomMap.set(posKey, atom);
                }
            }
            
            // Process bonds
            for (const bond of group.bonds) {
                const atom1Label = specialPositionMap.get(
                    createSymAtomLabel(bond.atom1Label, symmString),
                ) || createSymAtomLabel(bond.atom1Label, symmString);
                
                const atom2Label = specialPositionMap.get(
                    createSymAtomLabel(bond.atom2Label, symmString),
                ) || createSymAtomLabel(bond.atom2Label, symmString);
                
                // Skip self-bonds
                if (atom1Label === atom2Label) {
                    continue;
                }
                
                const bondId = createBondIdentifier(atom1Label, atom2Label);
                if (!bondMap.has(bondId)) {
                    bondMap.set(bondId, new Bond(
                        atom1Label,
                        atom2Label,
                        bond.bondLength,
                        bond.bondLengthSU,
                        '.',
                    ));
                }
            }
            
            // Process hydrogen bonds
            for (const hbond of group.hBonds) {
                const donorLabel = specialPositionMap.get(
                    createSymAtomLabel(hbond.donorAtomLabel, symmString),
                ) || createSymAtomLabel(hbond.donorAtomLabel, symmString);
                
                const hydrogenLabel = specialPositionMap.get(
                    createSymAtomLabel(hbond.hydrogenAtomLabel, symmString),
                ) || createSymAtomLabel(hbond.hydrogenAtomLabel, symmString);
                
                const acceptorLabel = specialPositionMap.get(
                    createSymAtomLabel(hbond.acceptorAtomLabel, symmString),
                ) || createSymAtomLabel(hbond.acceptorAtomLabel, symmString);
                
                const hbondId = createHBondIdentifier(donorLabel, hydrogenLabel, acceptorLabel);
                if (!hbondMap.has(hbondId)) {
                    hbondMap.set(hbondId, new HBond(
                        donorLabel,
                        hydrogenLabel,
                        acceptorLabel,
                        hbond.donorHydrogenDistance,
                        hbond.donorHydrogenDistanceSU,
                        hbond.acceptorHydrogenDistance,
                        hbond.acceptorHydrogenDistanceSU,
                        hbond.donorAcceptorDistance,
                        hbond.donorAcceptorDistanceSU,
                        hbond.hBondAngle,
                        hbond.hBondAngleSU,
                        '.',
                    ));
                }
            }
        }
    }
    
    // Convert collections to arrays
    const finalAtoms = Array.from(atomMap.values());
    const atomLabelSet = new Set(finalAtoms.map(a => a.label));
    
    // Filter bonds to ensure both atoms exist
    const finalBonds = Array.from(bondMap.values()).filter(bond =>
        atomLabelSet.has(bond.atom1Label) && atomLabelSet.has(bond.atom2Label),
    );
    
    // Process inter-group bonds from the structure level
    for (const bond of structure.bonds) {
        // Skip bonds already handled within groups
        if (bond.atom2SiteSymmetry && bond.atom2SiteSymmetry !== '.') {
            // This is an inter-group bond with symmetry
            for (const symOps of growSymIds) {
                for (const symId of symOps) {
                    const symOpIndex = structure.symmetry.operationIds.get(symId);
                    const symOp = structure.symmetry.symmetryOperations[symOpIndex];
                    
                    const symmCentre = getSymmetryCentre(limits, symOp);
                    const offsetX = Math.round(symmCentre.x);
                    const offsetY = Math.round(symmCentre.y);
                    const offsetZ = Math.round(symmCentre.z);
                    const translationString = `${5 + offsetX}${5 + offsetY}${5 + offsetZ}`;
                    const symmString = `${symId}_${translationString}`;
                    
                    // Apply symmetry to atom1
                    const atom1Label = specialPositionMap.get(
                        createSymAtomLabel(bond.atom1Label, symmString),
                    ) || createSymAtomLabel(bond.atom1Label, symmString);
                    
                    // Combine symmetries for atom2
                    const atom2Symm = structure.symmetry.combineSymmetryCodes(
                        symmString,
                        bond.atom2SiteSymmetry,
                    );
                    const atom2Label = specialPositionMap.get(
                        createSymAtomLabel(bond.atom2Label, atom2Symm),
                    ) || createSymAtomLabel(bond.atom2Label, atom2Symm);
                    
                    if (atom1Label === atom2Label) {
                        continue; 
                    }
                    
                    const bondId = createBondIdentifier(atom1Label, atom2Label);
                    if (!bondMap.has(bondId) && 
                        atomLabelSet.has(atom1Label) && 
                        atomLabelSet.has(atom2Label)) {
                        bondMap.set(bondId, new Bond(
                            atom1Label,
                            atom2Label,
                            bond.bondLength,
                            bond.bondLengthSU,
                            '.',
                        ));
                        finalBonds.push(bondMap.get(bondId));
                    }
                }
            }
        }
    }
    
    // Filter H-bonds to ensure all atoms exist
    const finalHBonds = Array.from(hbondMap.values()).filter(hbond =>
        atomLabelSet.has(hbond.donorAtomLabel) && 
        atomLabelSet.has(hbond.hydrogenAtomLabel) &&
        atomLabelSet.has(hbond.acceptorAtomLabel),
    );
    
    // Process inter-group H-bonds from the structure level
    for (const hbond of structure.hBonds) {
        if (hbond.acceptorAtomSymmetry && hbond.acceptorAtomSymmetry !== '.') {
            // This is an inter-group H-bond with symmetry
            for (const symOps of growSymIds) {
                for (const symId of symOps) {
                    const symOpIndex = structure.symmetry.operationIds.get(symId);
                    const symOp = structure.symmetry.symmetryOperations[symOpIndex];
                    
                    const symmCentre = getSymmetryCentre(limits, symOp);
                    const offsetX = Math.round(symmCentre.x);
                    const offsetY = Math.round(symmCentre.y);
                    const offsetZ = Math.round(symmCentre.z);
                    const translationString = `${5 + offsetX}${5 + offsetY}${5 + offsetZ}`;
                    const symmString = `${symId}_${translationString}`;
                    
                    const donorLabel = specialPositionMap.get(
                        createSymAtomLabel(hbond.donorAtomLabel, symmString),
                    ) || createSymAtomLabel(hbond.donorAtomLabel, symmString);
                    
                    const hydrogenLabel = specialPositionMap.get(
                        createSymAtomLabel(hbond.hydrogenAtomLabel, symmString),
                    ) || createSymAtomLabel(hbond.hydrogenAtomLabel, symmString);
                    
                    // Combine symmetries for acceptor
                    const acceptorSymm = structure.symmetry.combineSymmetryCodes(
                        symmString,
                        hbond.acceptorAtomSymmetry,
                    );
                    const acceptorLabel = specialPositionMap.get(
                        createSymAtomLabel(hbond.acceptorAtomLabel, acceptorSymm),
                    ) || createSymAtomLabel(hbond.acceptorAtomLabel, acceptorSymm);
                    
                    const hbondId = createHBondIdentifier(donorLabel, hydrogenLabel, acceptorLabel);
                    if (!hbondMap.has(hbondId) &&
                        atomLabelSet.has(donorLabel) && 
                        atomLabelSet.has(hydrogenLabel) && 
                        atomLabelSet.has(acceptorLabel)) {
                        hbondMap.set(hbondId, new HBond(
                            donorLabel,
                            hydrogenLabel,
                            acceptorLabel,
                            hbond.donorHydrogenDistance,
                            hbond.donorHydrogenDistanceSU,
                            hbond.acceptorHydrogenDistance,
                            hbond.acceptorHydrogenDistanceSU,
                            hbond.donorAcceptorDistance,
                            hbond.donorAcceptorDistanceSU,
                            hbond.hBondAngle,
                            hbond.hBondAngleSU,
                            '.',
                        ));
                        finalHBonds.push(hbondMap.get(hbondId));
                    }
                }
            }
        }
    }
    
    return new CrystalStructure(
        structure.cell,
        finalAtoms,
        finalBonds,
        finalHBonds,
        structure.symmetry,
    );
}